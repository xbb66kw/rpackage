% Generated by roxygen2 (4.0.2): do not edit by hand
\docType{methods}
\name{aggregateByKey}
\alias{aggregateByKey}
\alias{aggregateByKey,RDD,ANY,ANY,ANY,integer-method}
\title{Aggregate a pair RDD by each key.}
\usage{
aggregateByKey(rdd, zeroValue, seqOp, combOp, numPartitions)

\S4method{aggregateByKey}{RDD,ANY,ANY,ANY,integer}(rdd, zeroValue, seqOp,
  combOp, numPartitions)
}
\arguments{
\item{rdd}{An RDD.}

\item{zeroValue}{A neutral "zero value".}

\item{seqOp}{A function to aggregate the values of each key. It may return
a different result type from the type of the values.}

\item{combOp}{A function to aggregate results of seqOp.}
}
\value{
An RDD containing the aggregation result.
}
\description{
Aggregate the values of each key in an RDD, using given combine functions
and a neutral "zero value". This function can return a different result type,
U, than the type of the values in this RDD, V. Thus, we need one operation
for merging a V into a U and one operation for merging two U's, The former
operation is used for merging values within a partition, and the latter is
used for merging values between partitions. To avoid memory allocation, both
of these functions are allowed to modify and return their first argument
instead of creating a new U.
}
\examples{
\dontrun{
sc <- sparkR.init()
rdd <- parallelize(sc, list(list(1, 1), list(1, 2), list(2, 3), list(2, 4)))
zeroValue <- list(0, 0)
seqOp <- function(x, y) { list(x[[1]] + y, x[[2]] + 1) }
combOp <- function(x, y) { list(x[[1]] + y[[1]], x[[2]] + y[[2]]) }
aggregateByKey(rdd, zeroValue, seqOp, combOp, 2L)
  # list(list(1, list(3, 2)), list(2, list(7, 2)))
}
}
\seealso{
foldByKey, combineByKey
}

